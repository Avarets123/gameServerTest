# Описание выполненного тестового задания

отрефакторить

## 1. Аутентификация с использованием токена.

Все из этого пункта выполнено, кроме опционального функционала (проверка прав доступа), заметил поздно (для его реализации нужно лишь: добавить роли в таблице пользователей, сохранить в `req` роль аутентифицированного пользователя, настроить гвард для проверки роли пользователя при получении запроса, и прикрепить к тому или иному роуту роли, которым он доступен).

Для проверки аутентификации добавлены следующие роуты:

- POST /auth/sign-up - регистрация пользователя, принимает боди
  `{ password: string, nickname: string }`, возвращает `{accessToken: string, refreshToken: string}`
- POST /auth/sign-in - аутентификация пользователя, принимает и возвращает тоже самое что и предыдущий роут
- POST /auth/refresh-tokens - обновление токенов, принимает боди `{refreshToken: string}`
- GET /users - получает всех зарегистрированных пользователей, доступен только аутентифицированному пользователю, в хедерах нужно отправить `Authorization: Bearer <token>`

## 2. Настройка и подключение Socket.io.

Также данный пункт выполнен полностью. Как мы знаем в `socket.io` токен можно передать двумя способами: в хедерах как с http и в объекте `handshake.auth`, как описано в документации. Я предусмотрел оба варианта передачи токена, для принимания токенов из хедера нужно в `.env` добавить переменную `AUTH_TYPE=HEADER`, если не передать сервер будет искать токен в `handshake.auth`.

## 3. Работа с Redis.

Тут тоже все выполнено. Для хранения данных в редисе с помощью `hset` возникли самые разные варианты и идеи, но решил сделать это следующим образом: `key: tournament:<tournamentName>_user:<userName>, value: { K: number, D: number, A: number }`

## 4. Инкрементация данных и обновление по socket.io и http.

И тут все выполнено.  
Socket.io:

- Для получения данных KDA слушать событие `kda:get`
- Для обновления данных KDA заэмитить событие `kda:increment` и отправить боди ` { tournament: string, nickname: string, incrementField: K | D | A }`, сервер обновит данные пользователя и результат будет отправлен клиенту на событие `kda:get`

Тут с сокетами получение KDA можно было сделать еще продвинутым образом, напимер, сделать возможным подписку на турнир и при изменении KDA игрока отправить всем подписчикам новое состание KDA. 

Http:
 - Для обновления данных KDA отправить пост запрос на `/kda/increment` с боди ` { tournament: string, nickname: string, incrementField: K | D | A }`
 - Для получения данных KDA отправить гет запрос на `/kda/:tournamentName/:userNickname`.  

Касаемо поля `nickname` возник такой вопрос:  нужно ли провалидировать его так чтобы принимался никнейм только зарегистрированных в сервисе пользователей или можно любой никнейм? Так как четкие требования на этот счет отсутствовали я решил разрешить любой никнейм. 

